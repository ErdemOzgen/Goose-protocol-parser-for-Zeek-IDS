diff --git a/scripts/base/init-bare.bro b/scripts/base/init-bare.bro
index 600a507d4..1c5cfd985 100644
--- a/scripts/base/init-bare.bro
+++ b/scripts/base/init-bare.bro
@@ -4941,6 +4941,23 @@ export {
 	option sampling_duration = 10min;
 }
 
+# Custom types added for GOOSE parsing.
+module goose_records;
+export{
+	type double_vec: vector of double;
+	type gcp: record
+	{
+		packet_ts: double &log;
+		src_mac: string &log;
+		dest_mac: string &log &optional;
+		stNum: count &log;
+		sqNum: count &log;
+		packet_type: string &log;
+		data_values: vector of double &log;
+		string_values: vector of string &log;
+	};
+}
+
 module GLOBAL;
 
 ## Seed for hashes computed internally for probabilistic data structures. Using
diff --git a/scripts/base/protocols/goose/Sample_Script_A.bro b/scripts/base/protocols/goose/Sample_Script_A.bro
new file mode 100644
index 000000000..c242b9b83
--- /dev/null
+++ b/scripts/base/protocols/goose/Sample_Script_A.bro
@@ -0,0 +1,23 @@
+# Sample GOOSE Script A
+# Prints to console and logs to a file a subset of the GOOSE fields
+
+@load base/frameworks/notice
+
+# Define a module name
+module Sample_A;
+
+# Create an ID for our new stream. By convention, this is called LOG.
+redef enum Log::ID += { LOG };
+
+event bro_init() &priority=5
+{
+	Log::create_stream(LOG, [$columns=goose_records::gcp, $path="goose"]);
+}
+
+
+# Entry point. This event will be generated by the event engine when a new packet arrives.
+event goose_packet_event(p:goose_records::gcp)
+{
+	print p;
+	Log::write(LOG, p);
+}
diff --git a/scripts/base/protocols/goose/Sample_Script_B.bro b/scripts/base/protocols/goose/Sample_Script_B.bro
new file mode 100644
index 000000000..ee34f2768
--- /dev/null
+++ b/scripts/base/protocols/goose/Sample_Script_B.bro
@@ -0,0 +1,25 @@
+# Define a module name
+module Sample_B;
+
+# Constant variable declarations
+const stNum_MIN = 1;
+const stNum_MAX = 4294967295;
+
+# Container to store IED identifier (e.g. gocbRef) where stNum has hit MAX value
+global ieds: set[string];
+
+# Entry point. This event will be generated by the event engine when a new packet arrives.
+event goose_packet_event(p:goose_records::gcp)
+{
+	# stNum value fails to rollover correctly
+	if(p$packet_type in ieds && p$stNum!=stNum_MIN)
+		print "Error: stNum failed to rollover", p;
+
+	# stNum value correctly rolls over from MAX to MIN
+	else if(p$packet_type in ieds && p$stNum==stNum_MIN)
+		delete ieds[p$packet_type];
+
+	# stNum reached the MAX
+	else if(p$stNum==stNum_MAX)
+		add ieds[p$packet_type];
+}
diff --git a/scripts/base/protocols/goose/Sample_Script_C.bro b/scripts/base/protocols/goose/Sample_Script_C.bro
new file mode 100644
index 000000000..ab81e38e3
--- /dev/null
+++ b/scripts/base/protocols/goose/Sample_Script_C.bro
@@ -0,0 +1,43 @@
+# Define a module name
+module Sample_C;
+
+# Forward Declaration
+global dataset_has_changed: function(packet_type: string, current_data_values: vector of double): bool;
+
+# Define a record to store previous packet data
+type previous_record: record {
+	stNum: count;
+	sqNum: count;
+	data_values: goose_records::double_vec;
+};
+
+# Define a container of previous packet data, indexed by gocbRef of type string
+global prev: table [string] of previous_record;
+
+# Entry point. This event will be generated by the event engine when a new packet arrives.
+event goose_packet_event(p: goose_records::gcp)
+{
+	if(dataset_has_changed(p$packet_type, p$data_values))
+	{
+		# When dataset changes, check that stNum increments by 1 and sqNum is reset
+		if(p$stNum != prev[p$packet_type]$stNum+1 || p$sqNum!=0)
+		{
+			print "Error in stNum/sqNum sequence", p;
+			print "Previous data", prev[p$packet_type];
+		}
+	}
+
+	# Store the packet data
+	prev[p$packet_type] = [$stNum = p$stNum, $sqNum = p$sqNum, $data_values = p$data_values];
+}
+
+function dataset_has_changed(packet_type: string, current_data_values: goose_records::double_vec): bool
+{
+	if([packet_type] in prev==F)
+		return F;
+
+	for (i in current_data_values)
+		if (prev[packet_type]$data_values[i]!=current_data_values[i])
+			return T;
+	return F;
+}
diff --git a/scripts/base/protocols/goose/__load__.bro b/scripts/base/protocols/goose/__load__.bro
new file mode 100644
index 000000000..d7bb3fa6d
--- /dev/null
+++ b/scripts/base/protocols/goose/__load__.bro
@@ -0,0 +1 @@
+@load ./Sample_Script_A.bro
\ No newline at end of file
diff --git a/src/Sessions.cc b/src/Sessions.cc
index 5709ad5f2..c88e42134 100644
--- a/src/Sessions.cc
+++ b/src/Sessions.cc
@@ -27,6 +27,7 @@
 #include "analyzer/protocol/interconn/events.bif.h"
 #include "analyzer/protocol/arp/ARP.h"
 #include "analyzer/protocol/arp/events.bif.h"
+#include "analyzer/protocol/goose/GOOSE.h"
 #include "Discard.h"
 #include "RuleMatcher.h"
 
@@ -149,8 +150,16 @@ NetSessions::NetSessions()
 		arp_analyzer = new analyzer::arp::ARP_Analyzer();
 	else
 		arp_analyzer = 0;
+
+	//todo specify a trigger point
+	if(true)
+		goose_analyzer= new analyzer::goose::GOOSE_Analyzer();
+	else
+		goose_analyzer= 0;
+
 	}
 
+
 NetSessions::~NetSessions()
 	{
 	delete ch;
@@ -158,6 +167,7 @@ NetSessions::~NetSessions()
 	delete SYN_OS_Fingerprinter;
 	delete pkt_profiler;
 	Unref(arp_analyzer);
+	Unref(goose_analyzer);
 	delete discarder;
 	delete stp_manager;
 	}
@@ -225,7 +235,10 @@ void NetSessions::NextPacket(double t, const Packet* pkt)
 		if ( arp_analyzer )
 			arp_analyzer->NextPacket(t, pkt);
 		}
-
+	else if (pkt->l3_proto == L3_GOOSE)
+		{
+			goose_analyzer->NextPacket(t,pkt);
+		}
 	else
 		{
 		Weird("unknown_packet_type", pkt);
diff --git a/src/Sessions.h b/src/Sessions.h
index b237428d2..af0acb96d 100644
--- a/src/Sessions.h
+++ b/src/Sessions.h
@@ -29,6 +29,7 @@ class PacketFilter;
 
 namespace analyzer { namespace stepping_stone { class SteppingStoneManager; } }
 namespace analyzer { namespace arp { class ARP_Analyzer; } }
+namespace analyzer { namespace goose{ class GOOSE_Analyzer;} }	//add goose namespace
 
 struct SessionStats {
 	int num_TCP_conns;
@@ -237,6 +238,7 @@ protected:
 	IPTunnelMap ip_tunnels;
 
 	analyzer::arp::ARP_Analyzer* arp_analyzer;
+	analyzer::goose::GOOSE_Analyzer* goose_analyzer;	//declare goose analyzer
 
 	analyzer::stepping_stone::SteppingStoneManager* stp_manager;
 	Discarder* discarder;
diff --git a/src/analyzer/protocol/CMakeLists.txt b/src/analyzer/protocol/CMakeLists.txt
index ff34d243e..f3466d9f7 100644
--- a/src/analyzer/protocol/CMakeLists.txt
+++ b/src/analyzer/protocol/CMakeLists.txt
@@ -11,6 +11,7 @@ add_subdirectory(dns)
 add_subdirectory(file)
 add_subdirectory(finger)
 add_subdirectory(ftp)
+add_subdirectory(goose)
 add_subdirectory(gnutella)
 add_subdirectory(gssapi)
 add_subdirectory(gtpv1)
diff --git a/src/analyzer/protocol/goose/CMakeLists.txt b/src/analyzer/protocol/goose/CMakeLists.txt
new file mode 100644
index 000000000..d6163e07a
--- /dev/null
+++ b/src/analyzer/protocol/goose/CMakeLists.txt
@@ -0,0 +1,8 @@
+include(BroPlugin)
+
+include_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
+
+bro_plugin_begin(Bro GOOSE)
+bro_plugin_cc(GOOSE.cc Plugin.cc asn1.c goose.c)
+bro_plugin_bif(events.bif types.bif)
+bro_plugin_end()
diff --git a/src/analyzer/protocol/goose/GOOSE.cc b/src/analyzer/protocol/goose/GOOSE.cc
new file mode 100644
index 000000000..53349ff12
--- /dev/null
+++ b/src/analyzer/protocol/goose/GOOSE.cc
@@ -0,0 +1,147 @@
+// See the file "COPYING" in the main distribution directory for copyright.
+
+#include "GOOSE.h"
+#include "Event.h"
+#include "Reporter.h"
+#include "events.bif.h"
+
+using namespace analyzer::goose;
+
+GOOSE_Analyzer::GOOSE_Analyzer()
+{
+	packet_count = 0;
+}
+
+GOOSE_Analyzer::~GOOSE_Analyzer()
+{
+	if(packet_count>0)
+	{
+		printf("Goose total packet count: %d\n", packet_count);
+	}
+}
+
+void GOOSE_Analyzer::BaseEvent(EventHandlerPtr e)
+{
+	val_list* vl = new val_list;
+	mgr.QueueEvent(e, vl);
+}
+
+void GOOSE_Analyzer::BaseEvent(EventHandlerPtr e, RecordVal* curr_pkt)
+{
+	val_list* vl = new val_list;
+	vl->append(curr_pkt);
+	mgr.QueueEvent(e, vl);
+}
+
+void GOOSE_Analyzer::GeneratePacketEvent(double pktTime, const char * srcMac, const char * dstMac,
+		unsigned int stNum, unsigned int sqNum, const char * pktType, vector<double> dblDatasetTable, vector<string> strDatasetTable)
+{
+	RecordVal* gse_current_packet = new RecordVal(BifType::Record::goose_records::gcp);
+
+	gse_current_packet->Assign(PACKET_TS, new Val(pktTime, TYPE_DOUBLE));	//packet_ts
+	gse_current_packet->Assign(SRC_MAC, new StringVal(srcMac));				//src_mac
+	gse_current_packet->Assign(DST_MAC, new StringVal(dstMac));				//dest_mac
+	gse_current_packet->Assign(STNUM, val_mgr->GetCount(stNum));			//st_num
+	gse_current_packet->Assign(SQNUM, val_mgr->GetCount(sqNum));			//sq_num
+	gse_current_packet->Assign(PACKET_TYPE, new StringVal(pktType));		//packet_type
+
+	//data values will be stored in a vector of double
+	VectorVal* gse_data_vector = new VectorVal(new VectorType(base_type(TYPE_DOUBLE)));
+	for(unsigned int i=0; i<dblDatasetTable.size();i++)
+		gse_data_vector->Assign((unsigned int)i, new Val(dblDatasetTable[i], TYPE_DOUBLE));
+	gse_current_packet->Assign(DATA_VALUES, gse_data_vector);
+
+	//string values will be stored in a vector of string
+	VectorVal* gse_str_vector = new VectorVal(new VectorType(base_type(TYPE_STRING)));
+	for(unsigned int i=0; i<strDatasetTable.size();i++)
+		gse_str_vector->Assign((unsigned int)i, new StringVal(strDatasetTable[i]));
+	gse_current_packet->Assign(STR_VALUES, gse_str_vector);				//str_values
+
+	BaseEvent(goose_packet_event, gse_current_packet);
+}
+
+void GOOSE_Analyzer::FormatMAC(unsigned char (&mac_address)[6], char* strMac)
+{
+	char tmpBuf [5] = {0};
+
+	//Generate C-string for the MAC address
+	for(unsigned char c: mac_address){
+		sprintf(tmpBuf, "%02X:", c);
+		strcat(strMac, tmpBuf);
+	}
+	strMac[strlen(strMac)-1] = '\0';
+}
+
+pair<vector<double>, vector<string>> GOOSE_Analyzer::FormatDataEntries(Goose_Packet goosePacket)
+{
+	vector<double> dblDatasetTable;
+	vector<string> strDatasetTable;
+
+	for(unsigned int i=0; i < goosePacket.parameter.numDatSetEntries; i++)
+	{
+		GOOSE_DATASETENTRY datasetEntry = goosePacket.dataSet.entry[i];
+
+		if(!datasetEntry.isValid) continue;
+
+		switch(datasetEntry.tag)
+		{
+			case TAG_DATASET_INTEGER:
+				dblDatasetTable.push_back(datasetEntry.value.intVal);
+				break;
+			case TAG_DATASET_BOOLEAN:
+				dblDatasetTable.push_back(datasetEntry.value.boolVal);
+				break;
+			case TAG_DATASET_FLOAT:
+				dblDatasetTable.push_back(datasetEntry.value.floatVal);
+				break;
+			case TAG_DATASET_UINTEGER:
+				dblDatasetTable.push_back(datasetEntry.value.uintVal);
+				break;
+			case TAG_DATASET_BIT_STRING:
+			case TAG_DATASET_OCTET_STRING:
+			case TAG_DATASET_VISIBLE_STRING:
+				strDatasetTable.push_back(datasetEntry.value.strVal);
+				break;
+			case TAG_DATASET_UTCTIME:
+				//todo This is a struct that requires conversion to a readable format
+				break;
+		}
+	}
+
+	return pair<vector<double>, vector<string>>(dblDatasetTable, strDatasetTable);
+}
+
+void GOOSE_Analyzer::NextPacket(double t, const Packet* pkt)
+	{
+		Goose_Packet goosePacket;
+		int actual_length=0;
+		char srcMac[MAX_MAC_STR_LEN]={0};
+		char dstMac[MAX_MAC_STR_LEN]={0};
+
+		const unsigned char* inputGoose = pkt->data;
+		goose_init_packet(&goosePacket);
+		packet_count++;
+
+		int ret = goose_decode(inputGoose, &actual_length, &goosePacket);
+
+		if (ret == DECODE_SUCCESS)
+		{
+			FormatMAC(goosePacket.header.SMac, srcMac);
+			FormatMAC(goosePacket.header.DMac, dstMac);
+
+			//Generate C-string for field gocbRef
+			char packetType [MAX_MSG_STR_LEN] = {0};
+			sprintf(packetType, "%s", goosePacket.parameter.gocbRef);
+
+			//Store the dataset values into a vector of double and vector of string
+			pair<vector<double>, vector<string>> dataset = FormatDataEntries(goosePacket);
+
+			//Generate an event
+			GeneratePacketEvent(pkt->time, srcMac, dstMac, goosePacket.parameter.stNum, goosePacket.parameter.sqNum, packetType, dataset.first, dataset.second);
+		}
+		else
+		{
+			reporter->Weird("GOOSE decode failed.");
+		}
+
+	}
diff --git a/src/analyzer/protocol/goose/GOOSE.h b/src/analyzer/protocol/goose/GOOSE.h
new file mode 100644
index 000000000..215fc383b
--- /dev/null
+++ b/src/analyzer/protocol/goose/GOOSE.h
@@ -0,0 +1,50 @@
+// See the file "COPYING" in the main distribution directory for copyright.
+#pragma once
+
+#include "bro-config.h"
+#include "NetVar.h"
+#include "Reporter.h"
+#include "src/analyzer/protocol/goose/types.bif.h"
+
+class Packet;
+extern "C" {
+  #include <pcap.h>
+  #include "goose.h"
+}
+
+
+namespace analyzer { namespace goose {
+
+#define MAX_MAC_STR_LEN 18
+#define MAX_MSG_STR_LEN 128
+
+typedef enum {
+	PACKET_TS,
+	SRC_MAC,
+	DST_MAC,
+	STNUM,
+	SQNUM,
+	PACKET_TYPE,
+	DATA_VALUES,
+	STR_VALUES
+} GSE_IDX;
+
+class GOOSE_Analyzer : public BroObj {
+public:
+	GOOSE_Analyzer();
+	~GOOSE_Analyzer() override;
+
+	void NextPacket(double t, const Packet* pkt);
+	void BaseEvent(EventHandlerPtr e);
+	void BaseEvent(EventHandlerPtr e, RecordVal* curr_pkt);
+	void GeneratePacketEvent(double pkt_time, const char * srcMac, const char * dstMac,
+			unsigned int stNum, unsigned int sqNum, const char * msgType,
+			vector<double>v, vector<string> s);
+
+protected:
+	int packet_count;
+	void FormatMAC(unsigned char (&mac_address)[6], char* strMac);
+	pair<vector<double>,vector<string>> FormatDataEntries(Goose_Packet goosePacket);
+};
+
+} } // namespace analyzer::*
diff --git a/src/analyzer/protocol/goose/Plugin.cc b/src/analyzer/protocol/goose/Plugin.cc
new file mode 100644
index 000000000..45cb2ff29
--- /dev/null
+++ b/src/analyzer/protocol/goose/Plugin.cc
@@ -0,0 +1,24 @@
+// See the file  in the main distribution directory for copyright.
+
+
+#include "plugin/Plugin.h"
+
+namespace plugin {
+namespace Bro_GOOSE {
+
+class Plugin : public plugin::Plugin {
+public:
+	plugin::Configuration Configure()
+		{
+		plugin::Configuration config;
+		config.name = "Bro::GOOSE";
+		config.description = "IEC61850 GOOSE Parser";
+	    config.version.major = 1;
+	    config.version.minor = 0;
+	    config.version.patch = 0;
+		return config;
+		}
+} plugin;
+
+}
+}
diff --git a/src/analyzer/protocol/goose/asn1.c b/src/analyzer/protocol/goose/asn1.c
new file mode 100755
index 000000000..11b2c65d0
--- /dev/null
+++ b/src/analyzer/protocol/goose/asn1.c
@@ -0,0 +1,258 @@
+#include "asn1.h"
+
+#include <stdlib.h>
+#include "stdio.h"
+#include <string.h>
+#include <assert.h>
+
+#include "goose.h"
+
+
+static int asn1_decode_tag(const unsigned char *tagBuf,int *tagLen,_Decode_Ctrl *ctrl);
+static int asn1_decode_length(const unsigned char *lengthBuf,int *lengthLen,_Decode_Ctrl *ctrl);
+static int asn1_decode_value(const unsigned char *valueBuf,int *valueLen,_Decode_Ctrl *ctrl);
+
+
+static int asn1_encode_tag(const _Encode_Ctrl *ctrl,unsigned char *tagBuf, int *tagLen);
+static int asn1_encode_length(const _Encode_Ctrl *ctrl,unsigned char *lengthBuf, int *lengthLen);
+static int asn1_encode_value(const _Encode_Ctrl *ctrl,unsigned char *valueBuf, int *valueLen);
+
+
+int asn1_decode(const unsigned char *buf,int *decodeLen,Decode_Ctrl *ctrl)
+{
+	int tagLen = 0,lengthLen = 0,valueLen = 0;
+	BOOL ret = ASN1_FAILURE;
+	_Decode_Ctrl privateCtrl;
+	*decodeLen = 0;
+	memset(ctrl,0,sizeof(Decode_Ctrl));
+	privateCtrl.ctrl = ctrl;
+	privateCtrl.lenType = LENGTH_FIXED;		//use default fixed length
+
+	ret = asn1_decode_tag(buf,&tagLen,&privateCtrl);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+
+	ret = asn1_decode_length(buf+tagLen,&lengthLen,&privateCtrl);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+	ret = asn1_decode_value(buf+tagLen+lengthLen,&valueLen,&privateCtrl);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+	*decodeLen = tagLen + lengthLen + valueLen;
+
+	return ret;
+}
+
+static int asn1_decode_tag(const unsigned char *tagBuf,int *tagLen,_Decode_Ctrl *privateCtrl)
+{
+	//if tag <= 30,tag encoded in one byte. if tag >30, tag encoded in multiple bytes.
+	unsigned char tmpTag = *(unsigned char*)tagBuf;
+	if ((unsigned int)(tmpTag&0X1F) > 30)
+	{
+		return ASN1_TAG_ERR;
+	}
+	else
+	{
+		privateCtrl->ctrl->tag = tmpTag;
+		*tagLen = 1;
+		return ASN1_SUCCESS;
+	}
+}
+
+static int asn1_decode_length(const unsigned char *lengthBuf,int *lengthLen,_Decode_Ctrl *privateCtrl)
+{
+	unsigned char tmp = *(unsigned char*)lengthBuf;	//first byte
+	int nByte = 0;
+	unsigned int length = 0;
+	int i = 0;
+
+	//variable length type
+	if (tmp == 0X80)
+	{
+		return ASN1_LENGTH_ERR;
+	}
+	//fixed length type, long type.
+	else if ((tmp & 0X80) == 0X80)
+	{
+		//count byte number of length
+		if (tmp == 0XFF)//shouldn't use 11111111B, use this limitation for future expansion
+		{
+			return ASN1_LENGTH_ERR;
+		}
+		nByte = tmp&0X7F;
+		if (nByte > 4)
+		{
+			return ASN1_LENGTH_ERR;
+		}
+
+		length=nByte;
+
+		privateCtrl->ctrl->length = (unsigned char)length;
+		*lengthLen = 1+nByte;
+		return ASN1_SUCCESS;
+	}
+	//fix length
+	else
+	{
+		privateCtrl->ctrl->length = (unsigned int)(tmp&0X7F);
+		*lengthLen = 1;
+		return ASN1_SUCCESS;
+	}
+	return ASN1_SUCCESS;
+}
+
+static int asn1_decode_value(const unsigned char *valueBuf,int *valueLen,_Decode_Ctrl *privateCtrl)
+{
+	if(privateCtrl->lenType == LENGTH_FIXED)
+	{
+		if ((privateCtrl->ctrl->tag & 0X20) != 0)		//tag.bit6 == 0
+		{
+			//struct type
+			privateCtrl->ctrl->value = 0;
+			*valueLen = 0;
+		}
+		else
+		{
+			//simple type
+			privateCtrl->ctrl->value = valueBuf;
+			*valueLen = privateCtrl->ctrl->length;
+		}
+	}
+	else
+	{
+		*valueLen = 0;
+	}
+	return ASN1_SUCCESS;
+}
+
+int asn1_encode(const Encode_Ctrl *ctrl,unsigned char *buf,int *encodeLen)
+{
+	int ret = ASN1_FAILURE;
+	int tagLen = 0, lengthLen = 0, valueLen = 0;
+	int pos = 0;
+	_Encode_Ctrl privateCtrl;
+
+	privateCtrl.ctrl = ctrl;
+	privateCtrl.lenType = LENGTH_FIXED;				//only support fixed length to encode
+	*encodeLen = 0;
+	//write encoded date to buf in reverse order
+	ret = asn1_encode_value(&privateCtrl,buf-pos,&valueLen);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+	pos += valueLen;
+
+	ret = asn1_encode_length(&privateCtrl,buf-pos,&lengthLen);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+	pos += lengthLen;
+
+	ret = asn1_encode_tag(&privateCtrl,buf-pos,&tagLen);
+	if (ret != ASN1_SUCCESS)
+	{
+		return ret;
+	}
+	pos += tagLen;
+	*encodeLen += pos;
+
+	return ASN1_SUCCESS;
+}
+
+static int asn1_encode_tag(const _Encode_Ctrl *privateCtrl,unsigned char *tagBuf, int *tagLen)
+{
+	//when tag <=30, encoded in one byte. when tag >30, encoded in multiple bytes.
+	unsigned char tmpTag = privateCtrl->ctrl->tag;
+	if ((unsigned int)(tmpTag&0X1F) > 30)
+	{
+		return ASN1_TAG_ERR; //fixed length tag is required. otherwise leads to encoding failure.
+	}
+	else
+	{
+		memcpy(tagBuf,&privateCtrl->ctrl->tag,1); //copy fixed length tag data to specific position
+		*tagLen = 1;
+		return ASN1_SUCCESS;
+	}
+	return ASN1_SUCCESS;
+}
+
+static int asn1_encode_length(const _Encode_Ctrl *privateCtrl,unsigned char *lengthBuf, int *lengthLen)
+{
+	unsigned char tmpUChar = 0;
+	unsigned int tmpUint = 0;
+	if (privateCtrl->lenType == LENGTH_FIXED)	//only support fixed length encoding
+	{
+		if (privateCtrl->ctrl->length <= 127)	// short fixed length
+		{
+			tmpUChar = (unsigned char)(privateCtrl->ctrl->length & 0X7F);
+			memset(lengthBuf,tmpUChar,1);
+			*lengthLen = 1;
+			return ASN1_SUCCESS;
+		}
+		else 									// long fixed length
+		{
+			//write next bytes
+			tmpUint = (unsigned int)privateCtrl->ctrl->length;
+			if ((tmpUint & 0x000000FF) != 0)
+			{
+				tmpUChar = tmpUint & 0xFF;
+				memset(lengthBuf,tmpUChar,1);
+				*lengthLen ++;
+			}
+			if((tmpUint & 0x0000FF00) != 0)
+			{
+				tmpUChar = (unsigned char)((tmpUint>>8)&0xFF);
+				memset(lengthBuf-(*lengthLen),tmpUChar,1);
+				*lengthLen ++;
+			}
+			if((tmpUint & 0x00FF0000) != 0)
+			{
+				tmpUChar = (unsigned char)((tmpUint>>16)&0xFF);
+				memset(lengthBuf-(*lengthLen),tmpUChar,1);
+				*lengthLen ++;
+			}
+			if((tmpUint & 0xFF000000) != 0)
+			{
+				tmpUChar = (unsigned char)((tmpUint>>24)&0xFF);
+				memset(lengthBuf-(*lengthLen),tmpUChar,1);
+				*lengthLen ++;
+			}
+			//write first byte
+			tmpUChar = (unsigned char)((*lengthLen)&0xFF)|0x80;
+			memset(lengthBuf - (*lengthLen),tmpUChar,1);
+			*lengthLen++;
+			return ASN1_SUCCESS;
+		}
+	}
+	else
+	{
+		return ASN1_LENGTH_ERR;
+	}
+	return ASN1_SUCCESS;
+}
+
+static int asn1_encode_value(const _Encode_Ctrl *privateCtrl,unsigned char *valueBuf, int *valueLen)
+{
+	if ((privateCtrl->ctrl->tag & 0X20) != 0)	//tag.bit6
+	{
+		//struct type, privateCtrl->ctrl->length stands for encoded value part, no need to encode value.
+		assert(privateCtrl->ctrl->value == 0);
+		*valueLen = 0;
+	}
+	else
+	{
+		//simple type, privateCtrl-ctrl->length is the length of encoded value part.
+		memcpy(valueBuf-(privateCtrl->ctrl->length-1),privateCtrl->ctrl->value,
+			privateCtrl->ctrl->length);
+		*valueLen = privateCtrl->ctrl->length;
+	}
+	return ASN1_SUCCESS;
+}
diff --git a/src/analyzer/protocol/goose/asn1.h b/src/analyzer/protocol/goose/asn1.h
new file mode 100755
index 000000000..4eaa95085
--- /dev/null
+++ b/src/analyzer/protocol/goose/asn1.h
@@ -0,0 +1,55 @@
+#ifndef ASN1_ASN1_H
+#define ASN1_ASN1_H
+#include "goose.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+//function return value
+#define ASN1_RET			0
+#define ASN1_SUCCESS		(ASN1_RET)
+#define ASN1_FAILURE		(ASN1_RET+1)
+#define ASN1_TAG_ERR		(ASN1_RET+2)
+#define ASN1_LENGTH_ERR		(ASN1_RET+3)
+#define ASN1_VALUE_ERR		(ASN1_RET+4)
+
+#define LENGTH_FIXED		0
+#define LENGTH_VARIABLE		1
+
+typedef struct DECODE_CTRL
+{
+	unsigned char	tag;
+	unsigned int	length;
+	const unsigned char* value;
+}Decode_Ctrl;
+
+typedef struct _DECODE_CTRL
+{
+	Decode_Ctrl *ctrl;
+	unsigned char lenType;
+}_Decode_Ctrl;
+
+typedef struct ENCODE_CTRL
+{
+	unsigned char	tag;
+	unsigned int	length;
+	const unsigned char* value;
+}Encode_Ctrl;
+
+typedef struct _ENCODE_CTRL
+{
+	const Encode_Ctrl *ctrl;
+	unsigned char lenType;
+}_Encode_Ctrl;
+
+int asn1_decode(const unsigned char *buf,int *decodeLen,Decode_Ctrl *ctrl);
+int asn1_encode(const Encode_Ctrl *ctrl,unsigned char *buf,int *encodeLen);
+
+#ifdef __cplusplus
+};
+#endif
+
+
+#endif
diff --git a/src/analyzer/protocol/goose/events.bif b/src/analyzer/protocol/goose/events.bif
new file mode 100644
index 000000000..200bcf7bd
--- /dev/null
+++ b/src/analyzer/protocol/goose/events.bif
@@ -0,0 +1,17 @@
+## Generated for every IEC61850 GOOSE packet observed
+##
+## gse_current_packet:	Extracted contents of the packet defined in custom type
+##						specified in init-bare.bro as
+##						type gcp: record
+##						{
+##							packet_ts: double &log;
+##							src_mac: string &log;
+##							dest_mac: string &log &optional;
+##							stNum: count &log;
+##							sqNum: count &log;
+##							packet_type: string &log;
+##							data_values: vector of double &log;
+##							string_values: vector of string &log;
+##						};
+##
+event goose_packet_event%(gse_current_packet:goose_records::gcp%);
diff --git a/src/analyzer/protocol/goose/goose.c b/src/analyzer/protocol/goose/goose.c
new file mode 100755
index 000000000..f8744a9db
--- /dev/null
+++ b/src/analyzer/protocol/goose/goose.c
@@ -0,0 +1,475 @@
+#include "goose.h"
+#include "asn1.h"
+#include <stdlib.h>
+#include "stdio.h"
+#include <string.h>
+
+static void convert_byte_order(unsigned char *data,int datalen);
+static void print_debug(const unsigned char* byteArray,const int byteCount,const char* comment);
+
+#ifdef GOOSE_DEBUG
+#define PRINT_DEBUG(byteArray,byteCount,comment)	/*\
+	print_debug(byteArray,byteCount,comment)*/
+#else
+#define PRINT_DEBUG(byteArray,byteCount,comment)
+#endif
+
+#if (OS_BYTE_ORDER==OS_LITTLE_ENDIAN)
+#define CONVERT_BYTE_ORDER(x)	\
+convert_byte_order((unsigned char*)(&x),sizeof(x))
+#else
+#define CONVERT_BYTE_ORDER(x)
+#endif
+
+// Input parameters: src, len, dest
+#define UCHAR_TO_UINT(ucharVal,ucharLen,uintVal)			\
+	uintVal = 0;											\
+	memcpy(((char*)&uintVal)+(sizeof(uintVal) - (ucharLen)),ucharVal,ucharLen);\
+	CONVERT_BYTE_ORDER(uintVal)
+
+/* If the starting bit is 1, the integer is negative. It is necessary to invert the initial
+ * bits which are set to 0 as we are using integer (32bits) to store the value. */
+#define UCHAR_TO_INT(ucharVal, ucharLen, intVal)\
+	{intVal = 0;\
+	const size_t bits = ucharLen*8;\
+	memcpy(((char*)&intVal)+(sizeof(intVal) - (ucharLen)),ucharVal,ucharLen);\
+	CONVERT_BYTE_ORDER(intVal);\
+	if((intVal >> (bits-1))==1 && bits!=32) intVal |= ~((1<<bits)-1);}
+
+/* Reference: https://iec61850.tissue-db.com/tissue/817
+ * The fixed-length GOOSE encoding for 32-bit floating point numbers specifies a length of 4 bytes, in IEEE 754 format.
+ * Existing GOOSE implementations encode 32-bit floats in 5 bytes, with the first byte being used to indicate the number of bits used for the exponent.
+ * For compatibility with 5 byte encoding, adjust the starting offset and set the correct length for the value.
+ */
+#define UCHAR_TO_FLOAT(ucharVal, ucharLen, floatVal)\
+	floatVal = 0.0;\
+	if((ucharLen)==5) { ucharVal = ucharVal + 1; ucharLen = ucharLen -1;	}\
+	memcpy(((char*)&floatVal)+(sizeof(floatVal) - (ucharLen)), ucharVal, ucharLen);\
+	CONVERT_BYTE_ORDER(floatVal);
+
+#define UINT_TO_UCHAR(uintVal,ucharVal,ucharLen)			\
+	ucharLen = 0;											\
+	if(uintVal & 0xFF)			{memset(ucharVal,(unsigned char)uintVal&0xFF,1);ucharLen++;}		\
+	if((uintVal>>8) & 0xFF)		{memset(ucharVal,(unsigned char)(uintVal>>8)&0xFF,1);ucharLen++;}	\
+	if((uintVal>>16) & 0xFF)	{memset(ucharVal,(unsigned char)(uintVal>>16)&0xFF,1);ucharLen++;}	\
+	if((uintVal>>24) & 0xFF)	{memset(ucharVal,(unsigned char)(uintVal>>24)&0xFF,1);ucharLen++;}
+
+#define UCHAR_TO_USHORT(ucharVal,ucharLen,ushortVal)		\
+	ushortVal = 0;											\
+	memcpy(((char*)&ushortVal)+(sizeof(ushortVal) - (ucharLen)),ucharVal,ucharLen);\
+	CONVERT_BYTE_ORDER(ushortVal)
+
+#define USHORT_TO_UCHAR(ushortVal,ucharVal,ucharLen)		\
+	if(ushortVal & 0xFF)		{memset(ucharVal,(unsigned char)ushortVal&0xFF,1);ucharLen++;}		\
+	if((ushortVal>>8) & 0xFF)	{memset(ucharVal,(unsigned char)(ushortVal>>8)&0xFF,1);ucharLen++;}
+
+#define UCHAR_TO_BOOL(ucharVal,ucharLen,boolVal)			\
+{	unsigned char c = 0;									\
+	memcpy(&c,ucharVal,ucharLen);							\
+	if(c) boolVal = 1;	}
+
+#define BOOL_TO_UCHAR(boolVal,ucharVal,ucharLen)			\
+	ucharLen = 1;											\
+	memcpy(ucharVal,&boolVal,ucharLen)
+
+//UTC_TIME
+#define UCHAR_TO_UTCTIME(ucharVal,ucharLen,utcVal)			\
+	memcpy((char*)&utcVal.secs,ucharVal,sizeof(utcVal.secs));	\
+	CONVERT_BYTE_ORDER(utcVal.secs);						\
+	memset(&utcVal.fraction,0,sizeof(utcVal.fraction));	\
+	memcpy(((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 3,ucharVal+4,1);\
+	memcpy(((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 2,ucharVal+5,1);\
+	memcpy(((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 1,ucharVal+6,1);\
+	CONVERT_BYTE_ORDER(utcVal.fraction);					\
+	memset(&utcVal.qflags,0,sizeof(utcVal.qflags));		\
+	memcpy(((char*)(&utcVal.qflags))+sizeof(utcVal.qflags)-1,ucharVal+7,1);\
+	CONVERT_BYTE_ORDER(utcVal.qflags)
+
+//UTC_TIME
+#define UTCTIME_TO_UCHAR(utcVal,ucharVal,ucharLen)			\
+	ucharLen =8;											\
+	CONVERT_BYTE_ORDER(utcVal.secs);						\
+	memcpy((char*)ucharVal,(char*)&utcVal.secs,sizeof(utcVal.secs));\
+	CONVERT_BYTE_ORDER(utcVal.fraction);					\
+	memcpy(ucharVal+4,((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 3,1);\
+	memcpy(ucharVal+5,((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 2,1);\
+	memcpy(ucharVal+6,((char*)(&utcVal.fraction))+sizeof(utcVal.fraction) - 1,1);\
+	CONVERT_BYTE_ORDER(utcVal.qflags);						\
+	memcpy(ucharVal+7,((char*)(&utcVal.qflags))+sizeof(utcVal.qflags)-1,1)
+
+// Bit String. The first data byte indicates the unused bits in the last byte.
+#define UCHAR_TO_BITSTR(ucharVal, ucharLen, bitStrVal)													\
+{	unsigned int bitPadding = ucharVal[0];																\
+	for(int i=1; i<ucharLen-1; i++)																		\
+		sprintf(bitStrVal + strlen(bitStrVal), "%02x", (unsigned char)ucharVal[i]);						\
+	sprintf(bitStrVal + strlen(bitStrVal), "%02x", (unsigned char)(ucharVal[ucharLen-1]>>bitPadding));	}
+
+#define BITSTR_TO_UCHAR(bitStrVal,ucharVal,ucharLen)		\
+	ucharLen = 3;											\
+	memcpy(ucharVal,&bitStrVal,ucharLen)
+
+// Octet String. Same as Bit String without the padding byte.
+#define UCHAR_TO_OCTETSTR(ucharVal, ucharLen, octetStrVal)								\
+	for(int i=0;i<ucharLen;i++)															\
+		sprintf(octetStrVal + strlen(octetStrVal), "%02x", (unsigned char)ucharVal[i]);
+
+// Visible String
+#define UCHAR_TO_VSTRING(ucharVal,ucharLen,vstrVal)			\
+	memcpy(vstrVal,ucharVal,ucharLen)
+
+
+//Visible String
+#define VSTRING_TO_UCHAR(vstrVal,ucharVal,ucharLen)			\
+	ucharLen = strlen(vstrVal);								\
+	memcpy(ucharVal,vstrVal,ucharLen)
+
+void goose_init_packet(Goose_Packet* packet)
+{
+	memset(packet,0,sizeof(Goose_Packet));
+}
+
+int goose_decode(const unsigned char *buf,int *len,Goose_Packet *packet)
+{
+	int headerLen = 0;
+	int parameterLen = 0;
+	int datasetLen = 0;
+	int ret = DECODE_FAILURE;
+	int pos = 0;
+	*len = 0;
+	ret = goose_decode_header(buf+pos,&headerLen,packet);
+	if (ret != DECODE_SUCCESS)
+	{
+		return ret;
+	}
+	pos += headerLen;
+
+	ret = goose_decode_parameter(buf+pos,&parameterLen,packet);
+	if (ret != DECODE_SUCCESS)
+	{
+		return ret;
+	}
+	pos += parameterLen;
+
+	ret = goose_decode_dataset(buf+pos,&datasetLen,packet);
+	if (ret != DECODE_SUCCESS)
+	{
+		return ret;
+	}
+	pos += datasetLen;
+	*len += pos;
+	return DECODE_SUCCESS;
+}
+
+int goose_decode_header(const unsigned char *headerBuf,int *len,Goose_Packet *packet)
+{
+	int pos = 0;
+	Goose_Header *header = &packet->header;
+	//destination MAC address
+	PRINT_DEBUG(headerBuf,6,"Destination MAC address");
+	header->DMac[0] = headerBuf[pos++];
+	header->DMac[1] = headerBuf[pos++];
+	header->DMac[2] = headerBuf[pos++];
+	header->DMac[3] = headerBuf[pos++];
+	header->DMac[4] = headerBuf[pos++];
+	header->DMac[5] = headerBuf[pos++];
+
+	//source MAC address
+	PRINT_DEBUG(headerBuf+pos,6,"Source MAC address");
+	header->SMac[0] = headerBuf[pos++];
+	header->SMac[1] = headerBuf[pos++];
+	header->SMac[2] = headerBuf[pos++];
+	header->SMac[3] = headerBuf[pos++];
+	header->SMac[4] = headerBuf[pos++];
+	header->SMac[5] = headerBuf[pos++];
+
+	unsigned char tmp_VLAN_tag[2];
+	memcpy(tmp_VLAN_tag,headerBuf+pos,2);
+	if(!(tmp_VLAN_tag[0]==0x88 && tmp_VLAN_tag[1]==0xb8))
+	{
+		PRINT_DEBUG(headerBuf+pos,2,"TPID");
+		memcpy(header->TPID,headerBuf+pos,2);
+		pos += 2;
+
+		PRINT_DEBUG(headerBuf+pos,2,"TCI");
+		memcpy(header->TCI,headerBuf+pos,2);
+		pos += 2;
+	}
+
+	PRINT_DEBUG(headerBuf+pos,2,"Ethertype");
+	memcpy(header->Ethertype,headerBuf+pos,2);
+	pos += 2;
+
+	PRINT_DEBUG(headerBuf+pos,2,"APPID");
+	memcpy(header->APPID,headerBuf+pos,sizeof(header->APPID));
+	pos += 2;
+
+	PRINT_DEBUG(headerBuf+pos,2,"Length");
+	UCHAR_TO_USHORT(headerBuf+pos,2,header->Length);
+	pos += 2;
+
+	PRINT_DEBUG(headerBuf+pos,2,"Reserved1");
+	memcpy(header->Reserved1,headerBuf+pos,2);
+	pos += 2;
+
+	PRINT_DEBUG(headerBuf+pos,2,"Reserved2");
+	memcpy(header->Reserved2,headerBuf+pos,2);
+	pos += 2;
+
+	packet->isHeaderValid = TRUE;
+
+	*len += pos;
+	return DECODE_SUCCESS;
+}
+
+int goose_decode_parameter(const unsigned char *parameterBuf,int *len,Goose_Packet *packet)
+{
+	Goose_Parameter *parameter = &packet->parameter;
+	int pos = 0;
+	int ret = DECODE_FAILURE;
+	int decodeLen = 0;
+	Decode_Ctrl ctrl;
+	*len = 0;
+
+	memset(parameter,0,sizeof(*parameter));
+
+	//APDU
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"APDU");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_APDU_LEN)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	pos+=decodeLen;
+
+	//GocbRef
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"GocbRef");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_GOCB_REF)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_VSTRING(ctrl.value,ctrl.length,parameter->gocbRef);
+	pos+=decodeLen;
+
+	//timeToLive
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"TimeToLive");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_TIME_LIVE)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UINT(ctrl.value,ctrl.length,parameter->timeToLive);
+	pos+=decodeLen;
+
+	//DataSetRef
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"DataSetRef");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_DATASET_RET)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_VSTRING(ctrl.value,ctrl.length,parameter->datSetRef);
+	pos += decodeLen;
+
+	//GoID
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"GoID");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_GOID)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_VSTRING(ctrl.value,ctrl.length,parameter->goID);
+	pos += decodeLen;
+
+	//TimeStatusChanged
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"TimeStatusChanged");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_TIME_STATUS)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UTCTIME(ctrl.value,ctrl.length,parameter->timeStatusChanged);
+	pos += decodeLen;
+
+	//stNum
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"stNum");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_STNUM)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UINT(ctrl.value,ctrl.length,parameter->stNum);
+	pos += decodeLen;
+
+	//sqNum
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"sqNum");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_SQNUM)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UINT(ctrl.value,ctrl.length,parameter->sqNum);
+	pos += decodeLen;
+
+	//test
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"test");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_TEST)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_BOOL(ctrl.value,ctrl.length,parameter->test);
+	pos += decodeLen;
+
+	//confRev
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"confRev");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_CONFREV)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UINT(ctrl.value,ctrl.length,parameter->confRev);
+	pos += decodeLen;
+
+	//ndsCom
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"ndsCom");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_NDSCOM)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_BOOL(ctrl.value,ctrl.length,parameter->needsCommissioning);
+	pos += decodeLen;
+
+	//numDataSetEntries
+	ret = asn1_decode(parameterBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(parameterBuf+pos,decodeLen,"numDataSetEntries");
+	if (ret != ASN1_SUCCESS || ctrl.tag != TAG_PARA_NUM_DATASET)
+	{
+		return DECODE_PARAMETER_ERR;
+	}
+	UCHAR_TO_UINT(ctrl.value,ctrl.length,parameter->numDatSetEntries);
+	pos += decodeLen;
+
+	*len = pos;
+
+	parameter->paraBufLen = pos;
+	packet->isParameterValid = TRUE;
+
+	return DECODE_SUCCESS;
+}
+
+int goose_decode_dataset(const unsigned char *datasetBuf,int *len,Goose_Packet *packet)
+{
+	int ret = DECODE_FAILURE;
+	int i=0;
+	int decodeLen = 0;
+	int pos = 0;
+	Goose_DataSetEntry* entry = 0;
+	Decode_Ctrl ctrl;
+	Goose_DataSet *dataset = &packet->dataSet;
+
+	memset(&ctrl,0,sizeof(ctrl));
+
+	if (packet->isParameterValid == FALSE)
+	{
+		return DECODE_FAILURE;
+	}
+
+	//DataSet APDU length
+	ret = asn1_decode(datasetBuf+pos,&decodeLen,&ctrl);
+	PRINT_DEBUG(datasetBuf+pos,decodeLen,"APDU length");
+	if (ret != ASN1_SUCCESS)
+	{
+		return DECODE_DATASET_ERR;
+	}
+	dataset->datasetBufLen = ctrl.length + decodeLen;
+	pos += decodeLen;
+	//DataSetEntries
+	for (i = 0; i < (int)packet->parameter.numDatSetEntries; ++i)
+	{
+		ret = asn1_decode(datasetBuf+pos,&decodeLen,&ctrl);
+		if (ret != ASN1_SUCCESS)
+		{
+			return DECODE_DATASET_ERR;
+		}
+		entry = dataset->entry+i;
+		entry->isValid = TRUE;
+		entry->tag = ctrl.tag;
+		switch (ctrl.tag)
+		{
+		case TAG_DATASET_BOOLEAN:
+			UCHAR_TO_BOOL(ctrl.value,1,entry->value.boolVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:BOOL");
+			break;
+		case TAG_DATASET_INTEGER:
+			UCHAR_TO_INT(ctrl.value, ctrl.length, entry->value.intVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:Integer");
+			break;
+		case TAG_DATASET_UINTEGER:
+			UCHAR_TO_UINT(ctrl.value,ctrl.length,entry->value.uintVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:UnsignedInteger");
+			break;
+		case TAG_DATASET_BIT_STRING:
+			UCHAR_TO_BITSTR(ctrl.value, ctrl.length, entry->value.strVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:BitString");
+			break;
+		case TAG_DATASET_OCTET_STRING:
+			UCHAR_TO_OCTETSTR(ctrl.value, ctrl.length, entry->value.strVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:OctetString");
+			break;
+		case TAG_DATASET_VISIBLE_STRING:
+			UCHAR_TO_VSTRING(ctrl.value, ctrl.length, entry->value.strVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:VisibleString");
+			break;
+		case TAG_DATASET_UTCTIME:
+			UCHAR_TO_UTCTIME(ctrl.value,ctrl.length,entry->value.utcVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:Utctime");
+			break;
+		case TAG_DATASET_FLOAT:
+			UCHAR_TO_FLOAT(ctrl.value, ctrl.length, entry->value.floatVal);
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:Float");
+			break;
+		default:
+			PRINT_DEBUG(datasetBuf+pos,decodeLen,"Data:Unknown");
+			break;
+		}
+		pos += decodeLen;
+	}
+
+	packet->isDataSetValid = TRUE;
+	*len = pos;
+
+	return DECODE_SUCCESS;
+}
+
+static void convert_byte_order(unsigned char *data,int datalen)
+{
+#if (OS_BYTE_ORDER==OS_LITTLE_ENDIAN)
+	unsigned char tempbuf[16];
+	int i;
+	if (datalen<=1 || datalen>16)
+		return;
+	for (i=0; i<datalen; i++)
+	{
+		tempbuf[i] =   data[datalen-1-i];
+	}
+	memcpy(data, tempbuf, datalen);
+#endif
+}
+
+static void print_debug(const unsigned char* byteArray,const int byteCount,const char* comment)
+{
+#ifdef GOOSE_DEBUG
+	int i = 0;
+        printf("%s",comment);
+	printf(":");
+	for (i = 0; i < byteCount;++i)
+	{
+		printf("%02x ",(unsigned int)*(byteArray+i));
+	}
+	printf("\n");
+
+
+#endif
+}
diff --git a/src/analyzer/protocol/goose/goose.h b/src/analyzer/protocol/goose/goose.h
new file mode 100755
index 000000000..2543c684d
--- /dev/null
+++ b/src/analyzer/protocol/goose/goose.h
@@ -0,0 +1,168 @@
+#ifndef ASN1_GOOSE_H
+#define ASN1_GOOSE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+//Byte order definition
+#define OS_BIG_ENDIAN		0		//Used on VxWorks OS
+#define OS_LITTLE_ENDIAN	1		//Used on Windows OS
+#define OS_BYTE_ORDER		OS_LITTLE_ENDIAN
+
+//Debug definition
+#ifndef GOOSE_DEBUG
+#define GOOSE_DEBUG
+#endif
+
+//type definition
+#ifndef BOOL
+#define BOOL	unsigned char
+#endif
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+//This struct is obsolete. Bit string will not be stored as a struct.
+typedef struct BIT_STRING
+{
+	unsigned char	invalidBitNum;
+	unsigned char	data[2];
+}Bit_string;
+
+typedef struct UTC_TIME
+{
+	unsigned int secs;
+	unsigned int fraction;
+	unsigned int qflags;
+}UTC_time;
+
+#define MAX_GOOSE_ENTRY_NUM			100
+#define MAX_GOOSE_PACKET_LEN		1540
+
+#define GOOSE_GOCBREF_LEN			65
+#define GOOSE_DATASETREF_LEN		65
+#define GOOSE_GOID_LEN				65
+#define GOOSE_DATA_MAX_LEN			128
+
+//goose packet struct definition
+typedef struct GOOSE_HEADER
+{
+	unsigned char		DMac[6];
+	unsigned char		SMac[6];
+	unsigned char		TPID[2];
+	unsigned char		TCI[2];
+	unsigned char 		Ethertype[2];
+	unsigned char		APPID[2];
+	unsigned short		Length;
+	unsigned char		Reserved1[2];
+	unsigned char		Reserved2[2];
+}Goose_Header;
+
+typedef struct GOOSE_PARAMETER
+{
+	unsigned int	paraBufLen;								//parameter ASN.1/BER encoding
+	unsigned char	gocbRef[GOOSE_GOCBREF_LEN];				//tag 0x80,len<=65
+	unsigned int	timeToLive;								//tag 0x81,len=4
+	unsigned char	datSetRef[GOOSE_DATASETREF_LEN];		//tag 0x82,len<=65
+	unsigned char	goID[GOOSE_GOID_LEN];					//tag 0x83,len<=65
+	UTC_time		timeStatusChanged;						//tag 0x84,len=8
+	unsigned int	stNum;									//tag 0x85,len<=4
+	unsigned int	sqNum;									//tag 0x86,len<=4
+	BOOL			test;									//tag 0x87,len=1
+	unsigned int	confRev;								//tag 0x88,len<=4
+	BOOL			needsCommissioning;						//tag 0x89,len=1
+	unsigned int	numDatSetEntries;						//tag 0x8a,len<=4
+}Goose_Parameter;
+
+typedef struct GOOSE_DATASETENTRY
+{
+	BOOL isValid;
+	unsigned char tag;
+	union
+	{
+		BOOL			boolVal;
+		int				intVal;
+		UTC_time		utcVal;
+		float			floatVal;
+		unsigned int	uintVal;
+		char			strVal[128]; //used for bitString, octetString & visibleString
+	}value;
+}Goose_DataSetEntry;
+
+typedef struct GOOSE_DATASET
+{
+	unsigned int datasetBufLen;
+	Goose_DataSetEntry entry[MAX_GOOSE_ENTRY_NUM];
+}Goose_DataSet;
+
+typedef struct GOOSE_PACKET
+{
+	Goose_Header		header;
+	Goose_Parameter		parameter;
+	Goose_DataSet		dataSet;
+	BOOL				isHeaderValid;
+	BOOL				isParameterValid;
+	BOOL				isDataSetValid;
+}Goose_Packet;
+
+//definition for tags of Goose_Parameter
+#define TAG_PARA_APDU_LEN			0x61
+#define TAG_PARA_GOCB_REF			0x80
+#define TAG_PARA_TIME_LIVE			0x81
+#define TAG_PARA_DATASET_RET		0x82
+#define TAG_PARA_GOID				0x83
+#define TAG_PARA_TIME_STATUS		0x84
+#define TAG_PARA_STNUM				0x85
+#define TAG_PARA_SQNUM				0x86
+#define TAG_PARA_TEST				0x87
+#define TAG_PARA_CONFREV			0x88
+#define TAG_PARA_NDSCOM				0x89
+#define TAG_PARA_NUM_DATASET		0x8a
+
+//definition for tags of Goose_DataSet
+#define TAG_DATASET_BOOLEAN			0x83
+#define TAG_DATASET_BIT_STRING		0x84
+#define TAG_DATASET_INTEGER			0X85
+#define TAG_DATASET_UINTEGER		0X86
+#define TAG_DATASET_FLOAT			0X87
+#define TAG_DATASET_OCTET_STRING	0x89
+#define TAG_DATASET_UTCTIME			0x91
+#define TAG_DATASET_APDU_LEN		0xAB
+#define TAG_DATASET_VISIBLE_STRING	0x8A
+
+//return values for decode function
+#define DECODE_RET					0
+#define DECODE_SUCCESS				(DECODE_RET)
+#define	DECODE_FAILURE				(DECODE_RET+1)
+#define	DECODE_HEADER_ERR			(DECODE_RET+2)
+#define DECODE_PARAMETER_ERR		(DECODE_RET+3)
+#define DECODE_DATASET_ERR			(DECODE_RET+4)
+
+//return values for encode function
+#define ENCODE_RET					0
+#define ENCODE_SUCCESS				(ENCODE_RET)
+#define ENCODE_FAILURE				(ENCODE_RET+1)
+#define	ENCODE_HEADER_ERR			(ENCODE_RET+2)
+#define ENCODE_PARAMETER_ERR		(ENCODE_RET+3)
+#define ENCODE_DATASET_ERR			(ENCODE_RET+4)
+
+// Goose packet initialization function
+void goose_init_packet(Goose_Packet* packet);
+
+// Goose contents decode function. Supports ASN.1 Format.
+int goose_decode(const unsigned char *buf,int *len,Goose_Packet *packet);
+
+int goose_decode_header(const unsigned char *headerBuf,int *len,Goose_Packet *packet);
+
+int goose_decode_parameter(const unsigned char *parameterBuf,int *len,Goose_Packet *packet);
+
+int goose_decode_dataset(const unsigned char *datasetBuf,int *len,Goose_Packet *packet);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/src/analyzer/protocol/goose/types.bif b/src/analyzer/protocol/goose/types.bif
new file mode 100644
index 000000000..594cc55da
--- /dev/null
+++ b/src/analyzer/protocol/goose/types.bif
@@ -0,0 +1,4 @@
+module goose_records;
+
+type double_vec: vector;
+type gcp: record;
\ No newline at end of file
diff --git a/src/iosource/Packet.cc b/src/iosource/Packet.cc
index 5b858e828..b6da9aca3 100644
--- a/src/iosource/Packet.cc
+++ b/src/iosource/Packet.cc
@@ -230,6 +230,10 @@ void Packet::ProcessLayer2()
 				l3_proto = L3_IPV6;
 			else if ( protocol == 0x0806 || protocol == 0x8035 )
 				l3_proto = L3_ARP;
+			else if ( protocol==0x88b8) //detect goose by type code
+				{
+					l3_proto = L3_GOOSE;
+				}
 			else
 				{
 				// Neither IPv4 nor IPv6.
diff --git a/src/iosource/Packet.h b/src/iosource/Packet.h
index ec29f39ff..1170de047 100644
--- a/src/iosource/Packet.h
+++ b/src/iosource/Packet.h
@@ -20,6 +20,7 @@ enum Layer3Proto {
 	L3_IPV4 = 1,	/// Layer 3 is IPv4.
 	L3_IPV6 = 2,	/// Layer 3 is IPv6.
 	L3_ARP = 3,	/// Layer 3 is ARP.
+	L3_GOOSE = 4,	///layer 3 is GOOSE.
 };
 
 /**
diff --git a/src/types.bif b/src/types.bif
index 145a8af89..5a5583215 100644
--- a/src/types.bif
+++ b/src/types.bif
@@ -207,6 +207,7 @@ enum layer3_proto %{
 	L3_IPV4,
 	L3_IPV6,
 	L3_ARP,
+	L3_GOOSE,	#IEC61850 GOOSE protocol
 	L3_UNKNOWN,
 %}
 
diff --git a/testing/btest/Baseline/scripts.base.protocols.goose.goose_test_script/goose.log b/testing/btest/Baseline/scripts.base.protocols.goose.goose_test_script/goose.log
new file mode 100644
index 000000000..c2dca491e
--- /dev/null
+++ b/testing/btest/Baseline/scripts.base.protocols.goose.goose_test_script/goose.log
@@ -0,0 +1,18 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	goose
+#open	2020-06-03-16-25-17
+#fields	packet_ts	src_mac	dest_mac	stNum	sqNum	packet_type	data_values	string_values
+#types	double	string	string	count	count	string	vector[double]	vector[string]
+1557387693.693201	00:09:8E:21:73:33	01:0C:CD:01:00:01	1	0	LIED10CTRL/LLN0$Status	1.0,1.0,0.0,1.0,0.0	(empty)
+1557387693.693329	00:09:8E:21:73:33	01:0C:CD:01:00:01	1	0	LIED10PROT/LLN0$Alarm	0.0,1.0,0.0,0.0,0.0	(empty)
+1557387693.694367	00:09:8E:21:73:33	01:0C:CD:01:00:01	1	0	LIED10MEAS/LLN0$Measurement	313.0,308.0,315.0,38107.0,38092.0,38116.0,30001762.0,18499266.0,49.950001,0.84	(empty)
+1557387693.696241	00:09:8E:21:73:32	01:0C:CD:01:00:01	1	0	LIED11CTRL/LLN0$Status	1.0,1.0,0.0,1.0,0.0	(empty)
+1557387693.696247	00:09:8E:21:73:32	01:0C:CD:01:00:01	1	0	LIED11PROT/LLN0$Alarm	0.0,1.0,0.0,0.0,0.0	(empty)
+1557387693.696248	00:09:8E:21:73:32	01:0C:CD:01:00:01	1	0	LIED11MEAS/LLN0$Measurement	310.0,305.0,311.0,38114.0,38118.0,38091.0,30000845.0,18501655.0,50.049999,0.83	(empty)
+1557387693.707115	00:09:8E:21:73:31	01:0C:CD:01:00:01	1	0	LIED12CTRL/LLN0$Status	1.0,1.0,0.0,1.0,0.0	(empty)
+1557387693.707123	00:09:8E:21:73:31	01:0C:CD:01:00:01	1	0	LIED12PROT/LLN0$Alarm	0.0,1.0,0.0,0.0,0.0	(empty)
+1557387693.707124	00:09:8E:21:73:31	01:0C:CD:01:00:01	1	0	LIED12MEAS/LLN0$Measurement	311.0,307.0,305.0,38116.0,38111.0,38116.0,29999195.0,18498602.0,49.98,0.87	(empty)
+#close	2020-06-03-16-25-17
diff --git a/testing/btest/Traces/goose/goose_normal_subset.pcapng b/testing/btest/Traces/goose/goose_normal_subset.pcapng
new file mode 100644
index 0000000000000000000000000000000000000000..799c20a1a1b6b2e04aaff667ed5c07f770313854
GIT binary patch
literal 2176
zcma)--%C?b9Kg@rT<KJLGQlKnuxP7x+uhH8N!eUZm^HSAp(R}Pro*|7{VFA5bIxBu
z50wPbf1vc#!vZ6T5K4uhhX@NPqJrwlH+!h>x#!ku_iXO4bI$jEzh~R$%RakTTVJnz
zju7fRd8mnj{g*sc$bmY-2{EMi8Q6<rB#d{b_X6v(8F{<e#HK9lY1YEoOzrM5R(~~^
z7-Ic?mz6UckQy~2PcWRk##%Yv#+i&(hjCC0i?LuoszPqmmK=%p3sF|z6^x1TAt5$w
zV9lJJv$Oj4V1iANI4blH3xnbSE5u3F$lplzCBum%f0Q#>Ig<f!5oX8SZh1%W4JxET
zVmNNGK&}R=HL%x}VS=*s{vELA@db?a%?AygKlbb9AjXraTVwD?-P#woWZ-%_ul|a%
z5FlYRz1!2_YU54LfX{Qp<2h&2`4d7S8PBLR@5W2ivL*5p)t6qsUC7R5v^j>EWY83Y
zrWt02L9>izei!7V7lJj5+m?7S_al4(19RWoIH0=?F`iWJG!&4KN;eR0ukU<-aJPnp
z*hogT^VK-Ll%=O-=r>v_G=LIZ2qb9CikZJ-3>cXCdfuU1ff!FJ^J9Ec$UIE%A<&(!
zRzHF66oq&)CXR^VL`GGcA1`+xTdqjjnCNa+wxON3<y6cum{yo4a%yyU9WSeR`IM_-
zUcBsswdw4$DNXg6_SH4mPIYNpq#ldC+Vlo!UYSdH#h39)QIow=<VkP2y?JGC6?=8~
zN`U57fjcezMt{8GOM6vZlD#TU6X;3Zdn$BAUfF^HnpXwpBCq)EyrLhFy`mRM8&jd1
z$~K5sc5sS^>A*I9#LH*AtYEK}*RWUKM(mZ_V!>Vo#y(KJavtBJdBvCT%3Q`PMNRff
zkte;){QRQqtzxgbd$wp^6}bQR%3Rv3;*#uDahgESwnVAW6?t{PcZ=p#fw{;l^LAd*
z56E88i*g%FS!El<D+f4bk=&B*Qm}0Ny<aW$V6WN^O82X8IqX$$-Y0pbfxmGG|CM1x
zrZwpDLhT}hnvpXCPhT+>XQQ!5DmVa-=DtyOfIQ4qs9HMP(EQ|%T8@|JYZt2^emX-w
LO9S!01AoVF>5V%E

literal 0
HcmV?d00001

diff --git a/testing/btest/scripts/base/protocols/goose/goose_test_script.bro b/testing/btest/scripts/base/protocols/goose/goose_test_script.bro
new file mode 100644
index 000000000..7a26af560
--- /dev/null
+++ b/testing/btest/scripts/base/protocols/goose/goose_test_script.bro
@@ -0,0 +1,2 @@
+# @TEST-EXEC: bro -r $TRACES/goose/goose_normal_subset.pcapng $SCRIPTS/goose-test.bro
+# @TEST-EXEC: btest-diff goose.log
diff --git a/testing/scripts/goose-test.bro b/testing/scripts/goose-test.bro
new file mode 100644
index 000000000..8ff19ba14
--- /dev/null
+++ b/testing/scripts/goose-test.bro
@@ -0,0 +1,19 @@
+# goose-test
+# Logs to a file a subset of the GOOSE fields
+
+@load base/frameworks/notice
+
+# Create an ID for our new stream. By convention, this is called LOG.
+redef enum Log::ID += { LOG };
+
+event bro_init() &priority=5
+{
+	Log::create_stream(LOG, [$columns=goose_records::gcp, $path="goose"]);
+}
+
+
+# Entry point. This event will be generated by the event engine when a new packet arrives.
+event goose_packet_event(p:goose_records::gcp)
+{
+	Log::write(LOG, p);
+}
